#第一次作业补充

新建一个solutionX类(X根据题号改变)，并在这个类中完成如下函数的功能实现，函数的参数即题意中的输入。<br/>

提交方式参见上一次作业，请在自己的文件夹内新建作业文件夹task1-1，提交这次作业的代码，一共十个类文件

示例：

```
class Solution {
    public void solveProblem(Param parameter) {
        
    }
}
```

<br/>


-------------
<br/>
###1. 二进制求和
**题目描述：**给定两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。

**示例1:**
`输入: a = "11", b = "1"
输出: "100"
`
**示例1:**
`输入: a = "1010", b = "1011"
输出: "10101"`

**完成以下函数：**

```
class Solution1 {
    public String addBinary(String a, String b) {
        
    }
}
```

<br/>

--------
<br/>


###2. 两数之和
**题目描述：**给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br/>
**示例：**给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1] 。<br/>
**完成以下函数：**

```
class Solution2 {
    public int[] twoSum(int[] nums, int target) {
        
    }
}
```
<br/>

-------
<br/>

###3. 求众数
**题目描述：**
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数最多的元素。

**示例1:**
`输入: [3,2,3]
输出: 3
`

**示例1:**
`输入: [2,2,1,1,1,2,2]
输出: 2
`

**完成以下函数：**

```
class Solution3 {
    public int majorityElement(int[] nums) {
        
    }
}
```


<br/>

-------
<br/>

###4. 罗马数字转整数

**题目描述：**罗马数字包含以下七种字符: I， V， X， L，C，D 和 M，他们的值对应下表所示：

| 字符 | 数值 |
| --- | :-- |
| I | 1 |
| V | 5 |
| X | 10 |
| L | 50 |
| C | 100 |
| D | 500 |
| M | 1000 |

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
示例1:
`输入: "III"
输出: 3`

示例 2:
`输入: "IV"
输出: 4`

示例 3:
`输入: "IX"
输出: 9`

示例 4:
`输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.`

示例 5:
`输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
`
<br/>
**完成以下函数：**

```
class Solution4 {
    public int romanToInt(String s) {
        
    }
}
```



<br/>

-------
<br/>

###5. 解码方法
**题目描述：**一条包含字母 A-Z 的消息通过以下方式进行了编码：

`'A' -> 1
'B' -> 2
...
'Z' -> 26`

给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例1:
`输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。`

示例2：
`输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。`

**完成以下函数：**

```
class Solution5 {
    public int numDecodings(String s) {
        
    }
}
```

<br/>

-------
<br/>

###6. 提莫攻击
**题目描述：**在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。

你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。

示例1:
`输入: [1,4], 2
输出: 4
原因: 在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。
在第 4 秒开始时，提莫再次攻击艾希，使得艾希获得另外 2 秒的中毒时间。
所以最终输出 4 秒。`

示例2：
`输入: [1,2], 2
输出: 3
原因: 在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。
但是在第 2 秒开始时，提莫再次攻击了已经处于中毒状态的艾希。
由于中毒状态不可叠加，提莫在第 2 秒开始时的这次攻击会在第 3 秒钟结束。
所以最终输出 3。`

**完成以下函数：**

```
class Solution7 {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        
    }
}
```

<br/>

-------
<br/>
###7. 斐波那契数
**题目描述：**斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
`F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.`
给定 N，计算 F(N)。

示例1:
`输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.`

示例2：
`输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.`

**完成以下函数：**

```
class Solution7 {
      public int fib(int N) {
        
    }
}
```


<br/>

-------
<br/>

###8. 单词接龙
**题目描述：**给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 每次转换只能改变一个字母。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 转换过程中的中间单词必须是字典中的单词。
**说明：**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 如果不存在这样的转换序列，返回一个空列表。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 所有单词具有相同的长度。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 所有单词只由小写字母组成。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 字典中不存在重复的单词。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。


示例1:
`输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]
输出:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]`

示例2：
`输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
输出: []
解释: endWord "cog" 不在字典中，所以不存在符合要求的转换序列。`

**完成以下函数：**

```
class Solution8 {
     public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        
     }
}
```


<br/>

-------
<br/>
###9. 爬楼梯
**题目描述：**假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例1:
`输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶`

示例2：
`输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶`

**完成以下函数：**

```
class Solution9 {
     public int climbStairs(int n) {
        
    }
}
```

<br/>

-------
<br/>


###10. 解数独
**题目描述：**编写一个程序，通过已填充的空格来解决数独问题。<br/>
一个数独的解法需遵循如下规则：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）数字 1-9 在每一列只能出现一次。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）数字 1-9 在每一行只能出现一次。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
其中，空白各用0表示。
一个解的示例如下图所示。![111111](media/15571966557829/111111.png)
![222222](media/15571966557829/222222.png)

**完成以下函数：**

```
class Solution10 {
    public void solveSudoku(char[][] board) {
        
    }
}
```






