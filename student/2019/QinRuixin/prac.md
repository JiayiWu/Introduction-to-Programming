8.Reader用于读取字符，InputStream用于读取字节，  
InputStreamReader用于转化，将字节流转化为字符流  
BufferedReader(Reader)  
BufferedInputStream(InputStream)  
Buffered是缓冲的，更高效，自带flush()，但仍然需要自己close().    
FileReader是Reader的子类.   
FileInputStream是InputStream的子类;  

FileOutputSteam与FileInputStream相对。  

在读取文件的时候如果没有读到文件，会抛出异常。  

10.前者可以通过编译，因为是方法重载（overloading），方法名相同，但参数列表不同，编译器可以根据参数找到对应的方法  
后者不可以通过编译，因为方法名和参数列表都相同，只有返回值不同，编译器无法找到要使用的方法   


10.新建一个Father类，同时自定义一个run方法。再新建一个Son类，继承Father类。然后建立Main方法，并new Son类执行run方法，观察具体调用的是哪个run方法。  
调用Son的run方法  

11.先调用父类构造器，再调用子类构造器  

12.**多态**  
结果为
Cat eat
Dog eat   
多态允许父类引用指向子类对象，使用多态方法通过父类引用来调用方法时，先检查父类中是否有相应的方法，若有则通过编译，在具体执行时将执行父类引用具体指向的子类对象中的方法。   
多态提高了灵活性和可拓展性，若需要增加父类的具体实现或子类，只需要新建子类实现或重写父类方法，再将父类引用指向新建的子类对象，再调用方法即可，不过若要调用子类特有方法，应先将父类引用向下转型。  

13.**接口**  
接口是描述类应具有的方法，但并不给出方法具体实现的抽象规范。  
接口支持多继承、多实现，可以用来弥补java中类无法多继承的缺陷。   
可以将没有继承关系的类的部分子类的相同方法抽象为接口，降低模块间的耦合度，便于后期维护。   
Serializable Cloneable等标记接口的可用于表明对象是否具有某种属性。   
**依赖倒置原则**  
1. 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。   
2. 抽象不应该依赖于具体，具体应该依赖于抽象。  
依赖倒置原则要求面向接口编程，可降低类之间的耦合性，提高系统的稳定性和可维护性。   

14.**抽象类和接口的区别**  
1. 接口没有构造器，抽象类可以有构造器。  
2. 接口中变量的修饰符默认为public static final，必须赋初值；抽象类中的变量没有限制。  
3. 之前接口中只能有抽象方法，修饰符默认为public abstract ，不能有方法体，java8后接口可以有默认方法与静态方法；而抽象类中可以有有方法体的具体方法。  
4. 子类可以实现多个接口，但只能实现一个抽象类。  
5. 接口是对行为的抽象，抽象类是对事物的抽象。  
