10.新建一个Practice类，类中建立三个名称为add的方法，返回值都为int类型，其中三个方法参数个数都不同。[提交prac.md文件]
具体伪代码如下图

```java
int add (int a,int b){
return a+b;
}

int add (int a,int b,int c){
return a+b+c;
}

int add (int a,int b,int c,int d){
return a+b+c+d;
}
```

同时参数个数保持相同，但返回值不同，具体伪代码如下图
```java
int add (int a,int b){
return a+b;
}

double add (int a,int b){
return a+b+1.0;
}

```
尝试上述两端代码是否可以编译，如果可以，请思考为什么可以。如果不可以，请阐述不可以原因。

**解答**
这两段代码都可以编译，第一段的代码是因为函数的参数不同，而第二段代码是因为函数的返回值不同，所以可以重载。  

10.新建一个Father类，同时自定义一个run方法。再新建一个Son类，继承Father类（使用extends字段），同时在该类中定义一个run方法。然后建立Main方法，并new Son类执行run方法，观察具体调用的是哪个run方法。[提交代码和prac.md文件] 

**解答**
在Father类中的run方法被Son类中的run方法重载，最后调用的是Son类中的run方法。在我的代码中，打印出了"From the son"。  

11.新建Father类和Son类，并且Son类继承Father类，思考在new Son对象的时候对象初始化顺序，即只调用子类构造器还是先调用子类构造器再调用父类构造器亦或是顺序相反。建议自己想一个方法进行验证。[提交代码和prac.md文件]  

**解答**
在对象初识化过程中，先调用父类构造器，在调用子类构造器，在我的代码的运行中，首先调用了父类构造器(打印"Constructes from Father")，然后调用了子类构造器(打印"Constructed from Son"),之后才运行了main方法中对于run方法的调用。  

##多态

1.多态是同一个行为具有多个不同表现形式或形态的能力。  

2.多态的优点  
>+ 消除类型之间的耦合关系
>+ 可替换性
>+ 可扩充性
>+ 接口性
>+ 灵活性
>+ 简化性

3.多态存在的必要条件  
>+ 继承
>+ 重写
>+ 父类引用指向子类对象

4.使用  
>1.在使用多态方式调用方法时，首先检查父类中是否有该方法。  
>2.多态极大的扩充了函数的扩展性

13.思考为什么我们需要建立接口？了解依赖导致原则（Dependence Inversion Principle）的好处。[提交prac.md文件]

**解答**  
在我看看来，接口为我们对于类的抽象更上一个层次，方便了我们对于具体的方法、变量的重写和不同功能的实现。 

>简单来说我觉得接口有以下的优点：  
>1. 简化代码:将重复部分的代码简化。  
>2. 降低维护成本，实现标准化:防止自定义类的干扰。  
>3. 降低代码耦合性：给软件带来了安全性和严密性。


依赖倒置原则：  
**定义**  
依赖倒置原则是程序要依赖于抽象接口，不依赖于具体实现。简单来说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。  
>正常的应该是高层的模块独立于底层的模块，这样子极大的提高了他们的可重复用性。  

>好处  
>1. 保证了高层模块的独立性，确保其可重复用性。  
>2. 保证从顶向下的编程方式，便于设计程序。  
>3. 放置低层的模块影响高层模块。  

14.了解抽象类和接口的区别，请自己动手进行试验。  

**解答**
1. 一个类可以可以实现多个接口，但是只能继承一个类。  
2. 抽象类是被继承的，而接口是被实现的。 
3. 接口中定义的变量只能是public、static;抽象类的变量是普通变量。  
4. 抽象类的抽象方法必须全部被子类实现，不然子类仍然是抽象类。对于一个接口来说，如果不能实现接口的所有方法，那么他是一个抽象类。
5. 接口可继承接口，也可以多继承接口，但是类只能单根继承。

##接口

**定义**  
接口是抽象方法的集合。  
**注释**
1. 接口不同于类，但是编写方式相似  
2. 接口无法被实例化，但是可以被实现  
3. 一个实现接口的类，必须实现接口中内所描述的所有方法，否则就必须被声明为抽象类  
4. 除此以外，接口类型可以用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象  
5. 接口每一个方法是隐式抽象的，内部的变量是public static final的  